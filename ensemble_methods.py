# -*- coding: utf-8 -*-
"""Ensemble Methods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HiX_PROwXAbpYq5uE_FQeZZ7c6wzpQ2M
"""

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from graphload import graphload
from auc_all_methods import similarity_indices

G, df, X, Y = graphload("usair97.gml")
X = np.asarray(X).astype('float32')
Y = np.asarray(Y).astype('float32')
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.3, random_state=1)

df

# make a prediction with a stacking ensemble
from sklearn.datasets import make_classification
from sklearn.ensemble import StackingClassifier
from sklearn.linear_model import LogisticRegression
import xgboost as xgb
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import RepeatedStratifiedKFold
from numpy import mean

# define the base models
def get_stack():
  level0 = list()
  level0.append(('lr',  LogisticRegression(random_state=4, solver='liblinear', max_iter=500, verbose=1)))
  level0.append(('xgb', xgb.XGBClassifier(objective= 'binary:logistic', eval_metric='auc', booster='gbtree', verbosity=1, subsample=0.5, learning_rate=0.4, n_estimators=100)))
# define meta learner model
  level1 =  LogisticRegression(random_state=2, solver='liblinear', max_iter=500, verbose=1)
# define the stacking ensemble
  model = StackingClassifier(estimators=level0, final_estimator=level1, cv=5)
  return model

# evaluate a give model using cross-validation
def evaluate_model(model, X, y):
	cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
	scores = cross_val_score(model, X, y, scoring='accuracy', cv=cv, n_jobs=-1, error_score='raise')
	return scores
  
# get a list of models to evaluate
def get_models():
	models = dict()
	models['lr'] = LogisticRegression(random_state=4, solver='liblinear', max_iter=500, verbose=1)
	models['xgb'] = xgb.XGBClassifier(objective= 'binary:logistic', eval_metric='auc', booster='gbtree', verbosity=1, subsample=0.5, learning_rate=0.4, n_estimators=100)
	models['stacking'] = get_stack()
	return models

models = get_models()
score = {}
for name, model in models.items():
  model.fit(X_train, y_train)
  score[name] = model.score(X_test, y_test)

xgb.plot_importance(models['xgb']).set_yticklabels(['CN','LHN2', 'CBL', 'MFI'])

df2 = similarity_indices(G)

from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import accuracy_score
from sklearn.metrics import f1_score
from sklearn.metrics import auc
from sklearn.metrics import roc_curve
from sklearn.metrics import precision_recall_curve
from sklearn.metrics import roc_auc_score
y_pred_stack = models['stacking'].predict(X_test)
y_pred_xgb = models['xgb'].predict(X_test)
y_pred_lr = models['lr'].predict(X_test)
fpr1, tpr1, thresholds1 = roc_curve(y_test, y_pred_lr)
fpr2, tpr2, thresholds2 = roc_curve(y_test, y_pred_xgb)
fpr3, tpr3, thresholds3 = roc_curve(y_test, y_pred_stack)
fpr4, tpr4, thresholds4 = precision_recall_curve(y_test, y_pred_lr)
fpr5, tpr5, thresholds5 = precision_recall_curve(y_test, y_pred_xgb)
fpr6, tpr6, thresholds6 = precision_recall_curve(y_test, y_pred_stack)

accuracy_score(y_test, y_pred_lr).round()

auc(fpr4, tpr4)

# df2['lr'] = [auc(fpr1, tpr1),accuracy_score(y_test, y_pred_lr), float(auc(fpr4, tpr4))]
df2['xgb'] = [auc(fpr2, tpr2),accuracy_score(y_test, y_pred_xgb), auc(fpr5, tpr5)]
df2['ensemble'] = [auc(fpr3, tpr3),accuracy_score(y_test, y_pred_stack), auc(fpr6, tpr6)]

import pandas as pd
df3 = pd.DataFrame(columns = ['accuracy', 'auc', 'precision', 'recall', 'f1', 'roc', 'aupr'])
df3.loc['lr'] = [accuracy_score(y_test, y_pred_lr),auc(fpr1, tpr1), precision_score( y_test, y_pred_lr), recall_score( y_test, y_pred_lr), f1_score( y_test, y_pred_lr), roc_auc_score( y_test, y_pred_lr), auc(fpr4, tpr4) ]
df3.loc['xgb'] = [accuracy_score(y_test, y_pred_xgb),auc(fpr2, tpr2), precision_score( y_test, y_pred_xgb), recall_score( y_test, y_pred_xgb), f1_score( y_test, y_pred_xgb), roc_auc_score( y_test, y_pred_xgb) , auc(fpr5, tpr5)]
df3.loc['ensemble'] = [accuracy_score(y_test, y_pred_stack),auc(fpr3, tpr3), precision_score( y_test, y_pred_stack), recall_score( y_test, y_pred_stack), f1_score( y_test, y_pred_stack), roc_auc_score( y_test, y_pred_stack), auc(fpr6, tpr6) ]

import pandas as pd
pd.set_option("display.max_rows", 4, "display.max_columns", 14)
print(df2)

import pandas as pd
pd.set_option("display.max_rows", 4, "display.max_columns", 14)
print(df3)

with pd.ExcelWriter('output.xlsx') as writer:  
    df2.to_excel(writer, sheet_name='similarity')
    df3.to_excel(writer, sheet_name='eval_metric')

